%code requires {

	typedef struct tnode {
		int value;
		char reg[100];
	} node_t;
}

%{
	#include <iostream>
	#include <fstream> 
	#include <bits/stdc++.h>

	#include "../src/symboltable/symbol.hpp"
	#include "../src/mips_generator/mips.hpp"
	#include "../src/utility/util.hpp"

	#include <typeinfo>	
	#include <stdio.h> 
	#include <stdlib.h>
	#include <string>
	#include <string.h>

	using namespace std;

	ofstream mips;
	stack <string> semantic_stack;
	string current_scope = "global";
	string current_variable_data_type = "NONE";

	SymbolTable st;
	MIPSCodeGenerator cg;

	int temporal_registers[10] = {};
	int saved_regsiters[8] = {};
	
%}

%define parse.error verbose

%union{

	int intVal;
	char charVal;
	char* stringVal;
	node_t node;
}



%token KW_VOID KW_IF KW_RETURN KW_INT KW_ELSE KW_MAIN KW_FOR KW_BREAK KW_CHAR KW_WHILE KW_CONTINUE KW_ELSEIF

%token NEW_LINE OTHER

%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULTIPLY OP_DIVIDE 
%token OP_LESS OP_LESS_EQUAL OP_EQUAL OP_NOT_EQUAL OP_GREATER OP_GREATER_EQUAL 
%token OP_BITWISE_OR OP_BITWISE_AND OP_BITWISE_XOR 
%token OP_LOGICAL_OR OP_LOGICAL_AND OP_LOGICAL_NOT 
%token ST_LPAR ST_RPAR ST_LCURL ST_RCURL ST_LBR ST_RBR 
%token ST_DOLLAR ST_COMMA ST_SEMICOLON

%token <charVal> LCHAR UCHAR NCHAR
%token <stringVal> IDENTIFIER
%token <intVal>	NUMBER

%type <intVal> function stmt_call_function
%type <node> expression ids


%start program


%left OP_LOGICAL_OR OP_LOGICAL_AND
%left OP_BITWISE_OR OP_BITWISE_XOR OP_BITWISE_AND
%left OP_EQUAL OP_NOT_EQUAL
%left OP_GREATER OP_GREATER_EQUAL
%left OP_LESS OP_LESS_EQUAL
%left OP_PLUS OP_MINUS
%left OP_MULTIPLY OP_DIVIDE
%left OP_LOGICAL_NOT


%%

program   :   		functions main

/* global_scope:		global_scope global_declare | 

global_declare: 	type IDENTIFIER OP_ASSIGN expression ST_DOLLAR */

functions :   		functions function | 

main:		  		KW_INT KW_MAIN ST_LPAR {current_scope = "main"; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts  ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}   
			  		|
			  		KW_VOID KW_MAIN ST_LPAR {current_scope = "main";  semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}

function  :   		KW_INT IDENTIFIER ST_LPAR {string str($2); current_scope = str; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts  ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}
			  		|
			  		KW_VOID IDENTIFIER ST_LPAR {string str($2); current_scope = str; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts ST_RCURL	{current_scope = semantic_stack.top(); semantic_stack.pop();}	

stmts: 		  		stmt stmts | 
stmt:		  		stmt_declare | stmt_assignment | stmt_if | stmt_return | stmt_while | stmt_call_function ST_DOLLAR

type:		  		KW_INT {current_variable_data_type = "int";} 
					| 
					KW_CHAR {current_variable_data_type = "char";}
stmt_declare: 		type IDENTIFIER ids {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							string register_name = find_free_register(saved_regsiters , 8 , 0);
							strcpy($3.reg , register_name.c_str());
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"" , $3.value);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					}
ids:		  		ST_DOLLAR {$$.value = 0;} | 
					ST_COMMA IDENTIFIER ids {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							string register_name = find_free_register(saved_regsiters , 8 , 0);
							strcpy($3.reg , register_name.c_str());
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"",$3.value);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					}; | 
					OP_ASSIGN expression ids {$$ = $2;}




stmt_call_function:	IDENTIFIER ST_LPAR fun_arguments ST_RPAR 

fun_arguments:		fun_args_part1 |
fun_args_part1:		expression fun_args_part2
fun_args_part2:		ST_COMMA fun_args_part1 |




stmt_assignment:	IDENTIFIER OP_ASSIGN expression ST_DOLLAR {
						string str($1);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							yyerror("variable is not declared");
							exit(1);
						}
						else
						{
							result->value = $3.value;
							clear_registers(temporal_registers , 10);
						}
					}

stmt_return:  		KW_RETURN expression ST_DOLLAR


stmt_if: 	  		matched | unmatched
matched: 	  		KW_IF ST_LPAR {current_scope = current_scope + "__if"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); } elseif
elseif:       		KW_ELSEIF ST_LPAR {current_scope = current_scope + "__elseif"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); } elseif | else	
else:         		KW_ELSE ST_LCURL {current_scope = current_scope + "__else"; semantic_stack.push(current_scope);} stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }
unmatched:    		KW_IF ST_LPAR {current_scope = current_scope + "__if"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }

stmt_while:			KW_WHILE ST_LPAR {current_scope = current_scope + "__while"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL loop_stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }
loop_stmts:			loop_stmts stmts | loop_stmts KW_BREAK ST_DOLLAR | loop_stmts KW_CONTINUE ST_DOLLAR | 



/* for:				KW_FOR ST_LPAR stmt_declare  */

expression: 		expression OP_PLUS expression {
	
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_PLUS , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.add(dst.reg , $1.reg , $3.reg);
					
					};
					|
					expression OP_MINUS expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_MINUS , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.sub(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_MULTIPLY expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_MULTIPLY , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.mul(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_DIVIDE expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_DIVIDE , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.div($1.reg , $3.reg);
						cg.divQ(dst.reg);
					};
					|
					expression OP_LESS expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_LESS , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.slt(dst.reg , $1.reg , $3.reg);

					};
					|
					expression OP_LESS_EQUAL expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_LESS_EQUAL , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.sle(dst.reg , $1.reg , $3.reg);

					};
					|
					expression OP_EQUAL expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_EQUAL , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.seq(dst.reg , $1.reg , $3.reg);

					};
					|
					expression OP_NOT_EQUAL expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_NOT_EQUAL , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.sne(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_GREATER expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_GREATER , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.sgt(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_GREATER_EQUAL expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_GREATER_EQUAL , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.sge(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_LOGICAL_OR expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_LOGICAL_OR , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg._or(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_LOGICAL_AND expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_LOGICAL_AND , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg._and(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_BITWISE_OR expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_BITWISE_OR , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg._or(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_BITWISE_AND expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_BITWISE_AND , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg._and(dst.reg , $1.reg , $3.reg);
					};
					|
					expression OP_BITWISE_XOR expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = calculate(OP_BITWISE_XOR , $1.value , $3.value);
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg._xor(dst.reg , $1.reg , $3.reg);
					};
					|

					OP_LOGICAL_NOT expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = $2.value == 0 ? 1 : 0;
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.neg(dst.reg , $2.reg);
					} | 
					OP_MINUS expression {
						node_t dst;
						string reg = find_free_register(temporal_registers , 10 , 1);
						dst.value = $2.value * -1;
						strcpy(dst.reg, reg.c_str());
						$$ = dst;

						cg.neg(dst.reg , $2.reg);
					} |

					ST_LPAR expression ST_RPAR {
						$$ = $2;

						cg.move($$.reg , $2.reg);
					} |
					IDENTIFIER {
						string str($1);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							yyerror("variable not found");
							exit(1);
						}
						else
						{
							node_t dst;
							dst.value = result->value;
							strcpy(dst.reg, result->reg.c_str());
							$$ = dst;

							cg.move(dst.reg , result->reg);	
						}
					} |
					NUMBER {
						node_t dst;
						dst.value = $1;
						$$ = dst;

						cg.li(dst.reg , $1);
					} |
					NCHAR {
						node_t dst;
						dst.value = $1;
						$$ = dst;

						cg.li(dst.reg , $1);
					} |
					UCHAR {
						node_t dst;
						dst.value = $1;
						$$ = dst;

						cg.li(dst.reg , $1);
					} |
					LCHAR {
						node_t dst;
						dst.value = $1;
						$$ = dst;

						cg.li(dst.reg , $1);
					} |
					stmt_call_function {
						node_t dst;
						dst.value = $1;
						$$ = dst;

						cg.li(dst.reg , $1);
					}


arguments:			args_part1 |
args_part1:			type IDENTIFIER {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							string register_name = find_free_register(saved_regsiters , 8 , 0);
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"" , 0);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					} args_part2
args_part2:			ST_COMMA args_part1 |
		

%%


int main(int argc, char *argv[])
{
    yyin = fopen(argv[1], "r");
	// it will be called in the expression of if
	mips.open("./mips.asm");

	cg.init(&mips);

    if(!yyparse())
		printf("\nParsing Complete\n");
	else
	{
		fprintf(stderr,"\nParsing Failed\n");
		exit(0);
	}
	
	// closing the opened file
	
	fclose(yyin);
    return 0;
}


%{
	#include <iostream>
	#include <fstream> 

	#include <bits/stdc++.h>
	#include "../src/symboltable/symbol.hpp"
	#include "../src/mips_generator/mips.hpp"

	#include <typeinfo>	
	#include <stdio.h> 
	#include <stdlib.h>
	#include <string>
	#include <string.h>

	using namespace std;

	int yyparse();
	void yyerror(const char *s);

	void showstack(stack <int> s);
	int calculate(int token , int leftVal , int rightVal);

	int find_free_register(int* array , int size);

	extern FILE* yyin;
	extern int yylex();
	extern int yylineno;
	extern char* yytext;

	ofstream mips;

	stack <string> semantic_stack;

	string current_scope = "global";
	string current_variable_data_type = "NONE";

	SymbolTable st;
	Node* node;

	MIPSCodeGenerator cg;

	int temporal_registers[10] = {};

	int saved_regsiters[8] = {};
	
%}

%define parse.error verbose

%union{

	int intVal;
	char charVal;
	char* stringVal;

}



%token KW_VOID KW_IF KW_RETURN KW_INT KW_ELSE KW_MAIN KW_FOR KW_BREAK KW_CHAR KW_WHILE KW_CONTINUE KW_ELSEIF

%token NEW_LINE OTHER

%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULTIPLY OP_DIVIDE 
%token OP_LESS OP_LESS_EQUAL OP_EQUAL OP_NOT_EQUAL OP_GREATER OP_GREATER_EQUAL 
%token OP_BITWISE_OR OP_BITWISE_AND OP_BITWISE_XOR 
%token OP_LOGICAL_OR OP_LOGICAL_AND OP_LOGICAL_NOT 
%token ST_LPAR ST_RPAR ST_LCURL ST_RCURL ST_LBR ST_RBR 
%token ST_DOLLAR ST_COMMA ST_SEMICOLON

%token <charVal> LCHAR UCHAR NCHAR
%token <stringVal> IDENTIFIER
%token <intVal>	NUMBER

%type <intVal> expression function ids stmt_call_function

%start program


%left OP_LOGICAL_OR OP_LOGICAL_AND
%left OP_BITWISE_OR OP_BITWISE_XOR OP_BITWISE_AND
%left OP_EQUAL OP_NOT_EQUAL
%left OP_GREATER OP_GREATER_EQUAL
%left OP_LESS OP_LESS_EQUAL
%left OP_PLUS OP_MINUS
%left OP_MULTIPLY OP_DIVIDE
%left OP_LOGICAL_NOT


%%

program   :   		functions main

/* global_scope:		global_scope global_declare | 

global_declare: 	type IDENTIFIER OP_ASSIGN expression ST_DOLLAR */

functions :   		functions function | 

main:		  		KW_INT KW_MAIN ST_LPAR {current_scope = "main"; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts  ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}   
			  		|
			  		KW_VOID KW_MAIN ST_LPAR {current_scope = "main";  semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}

function  :   		KW_INT IDENTIFIER ST_LPAR {string str($2); current_scope = str; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts  ST_RCURL {current_scope = semantic_stack.top(); semantic_stack.pop();}
			  		|
			  		KW_VOID IDENTIFIER ST_LPAR {string str($2); current_scope = str; semantic_stack.push(current_scope);} arguments ST_RPAR ST_LCURL stmts ST_RCURL	{current_scope = semantic_stack.top(); semantic_stack.pop();}	

stmts: 		  		stmt stmts | 
stmt:		  		stmt_declare | stmt_assignment | stmt_if | stmt_return | stmt_while | stmt_call_function ST_DOLLAR

type:		  		KW_INT {current_variable_data_type = "int";} 
					| 
					KW_CHAR {current_variable_data_type = "char";}
stmt_declare: 		type IDENTIFIER ids {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							int index_of_free_register = find_free_register(saved_regsiters , 8);
							string register_name = "$s" + to_string(index_of_free_register);
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"" , $3);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					}
ids:		  		ST_DOLLAR {$$ = 0;} | 
					ST_COMMA IDENTIFIER ids {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							int index_of_free_register = find_free_register(saved_regsiters , 8);
							string register_name = "$s" + to_string(index_of_free_register);
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"",$3);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					}; | 
					OP_ASSIGN expression ids {$$ = $2;}




stmt_call_function:	IDENTIFIER ST_LPAR fun_arguments ST_RPAR 

fun_arguments:		fun_args_part1 |
fun_args_part1:		expression fun_args_part2
fun_args_part2:		ST_COMMA fun_args_part1 |




stmt_assignment:	IDENTIFIER OP_ASSIGN expression ST_DOLLAR {
						string str($1);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							yyerror("variable is not declared");
							exit(1);
						}
						else
						{
							result->value = $3;
						}
					}

stmt_return:  		KW_RETURN expression ST_DOLLAR


stmt_if: 	  		matched | unmatched
matched: 	  		KW_IF ST_LPAR {current_scope = current_scope + "__if"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); } elseif
elseif:       		KW_ELSEIF ST_LPAR {current_scope = current_scope + "__elseif"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); } elseif | else	
else:         		KW_ELSE ST_LCURL {current_scope = current_scope + "__else"; semantic_stack.push(current_scope);} stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }
unmatched:    		KW_IF ST_LPAR {current_scope = current_scope + "__if"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }

stmt_while:			KW_WHILE ST_LPAR {current_scope = current_scope + "__while"; semantic_stack.push(current_scope);} expression ST_RPAR ST_LCURL loop_stmts ST_RCURL { semantic_stack.pop(); current_scope = semantic_stack.top(); }
loop_stmts:			loop_stmts stmts | loop_stmts KW_BREAK ST_DOLLAR | loop_stmts KW_CONTINUE ST_DOLLAR | 



/* for:				KW_FOR ST_LPAR stmt_declare  */

expression: 		expression OP_PLUS expression {
						$$ = calculate(OP_PLUS , $1 , $3);
					};
					|
					expression OP_MINUS expression {
						$$ = calculate(OP_MINUS , $1 , $3);
					};
					|
					expression OP_MULTIPLY expression {
						$$ = calculate(OP_MULTIPLY , $1 , $3);
					};
					|
					expression OP_DIVIDE expression {
						$$ = calculate(OP_DIVIDE , $1 , $3);
					};
					|
					expression OP_LESS expression {
						$$ = calculate(OP_LESS , $1 , $3);
					};
					|
					expression OP_LESS_EQUAL expression {
						$$ = calculate(OP_LESS_EQUAL , $1 , $3);
					};
					|
					expression OP_EQUAL expression {
						$$ = calculate(OP_EQUAL , $1 , $3);
					};
					|
					expression OP_NOT_EQUAL expression {
						$$ = calculate(OP_NOT_EQUAL , $1 , $3);
					};
					|
					expression OP_GREATER expression {
						$$ = calculate(OP_GREATER , $1 , $3);
					};
					|
					expression OP_GREATER_EQUAL expression {
						$$ = calculate(OP_GREATER_EQUAL , $1 , $3);
					};
					|
					expression OP_LOGICAL_OR expression {
						$$ = calculate(OP_LOGICAL_OR , $1 , $3);
					};
					|
					expression OP_LOGICAL_AND expression {
						$$ = calculate(OP_LOGICAL_AND , $1 , $3);
					};
					|
					expression OP_BITWISE_OR expression {
						$$ = calculate(OP_BITWISE_OR , $1 , $3);
					};
					|
					expression OP_BITWISE_AND expression {
						$$ = calculate(OP_BITWISE_AND , $1 , $3);
					};
					|
					expression OP_BITWISE_XOR expression {
						$$ = calculate(OP_BITWISE_XOR , $1 , $3);
					};
					|

					OP_LOGICAL_NOT expression {$$ = $2 == 0 ? 1 : 0;} | 
					OP_MINUS expression {$$ = -1 * $2;} |

					ST_LPAR expression ST_RPAR {$$ = $2;} |
					IDENTIFIER {
						string str($1);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							yyerror("variable not found");
							exit(1);
						}
						else
						{
							$$ = result->value;
						}
					} |
					NUMBER {
						$$ = $1;
					} |
					NCHAR {
						$$ = $1;
					} |
					UCHAR {
						$$ = $1;
					} |
					LCHAR {
						$$ = $1;
					} |
					stmt_call_function { $$ = $1 ;}


arguments:			args_part1 |
args_part1:			type IDENTIFIER {

						string str($2);
						Node* result = st.find(str , semantic_stack);
						if(result == NULL)
						{
							int index_of_free_register = find_free_register(saved_regsiters , 8);
							string register_name = "$s" + to_string(index_of_free_register);
							st.insert(str,current_scope,current_variable_data_type,yylineno,register_name,"" , 0);
						}
						else
						{
							yyerror("multiple declaration of variable");
							exit(1);
						}
					} args_part2
args_part2:			ST_COMMA args_part1 |
		

%%


int main(int argc, char *argv[])
{
    yyin = fopen(argv[1], "r");
	// it will be called in the expression of if
	mips.open("./mips");

	cg.init(&mips);

    if(!yyparse())
		printf("\nParsing Complete\n");
	else
	{
		fprintf(stderr,"\nParsing Failed\n");
		exit(0);
	}
	
	// closing the opened file
	mips.close();
	
	fclose(yyin);
    return 0;
}

void yyerror(const char *s) {
	fprintf(stderr,"Syntex Error in line number : %d : %s\n", yylineno, s);
}


int find_free_register(int* array , int size)
{
	for(int i = 0;i < size;i++)
	{
		if(array[i] == 0)
		{
			array[i] = 1;
			return i;
		}
	}
	return -1;
}

void showstack(stack <int> s) 
{ 
    while (!s.empty()) 
    { 
        cout << '\t' << s.top(); 
        s.pop(); 
    } 
    cout << '\n'; 
} 


int calculate(int token , int leftVal , int rightVal)
{
    switch (token)
    {
		case OP_PLUS:
			return (leftVal + rightVal);
			break;
		case OP_MINUS:
			return (leftVal - rightVal);
			break;
		case OP_MULTIPLY:
			return (leftVal * rightVal);
			break;
		case OP_DIVIDE:
			if(rightVal == 0)
			{
				yyerror("Division by Zero");
				exit(1);
			}
			return (leftVal / rightVal);
			break;
		case OP_LESS:
			return (leftVal < rightVal);
			break;
		case OP_LESS_EQUAL:
			return (leftVal <= rightVal);
			break;
		case OP_EQUAL:
			return (leftVal == rightVal);
			break;
		case OP_NOT_EQUAL:
			return (leftVal != rightVal);
			break;
		case OP_GREATER:
			return (leftVal > rightVal);
			break;
		case OP_GREATER_EQUAL:
			return (leftVal >= rightVal);
			break;
		case OP_LOGICAL_OR:
			return (leftVal || rightVal);
			break;
		case OP_LOGICAL_AND:
			return (leftVal && rightVal);
			break;
		case OP_BITWISE_OR:
			return (leftVal | rightVal);
			break;
		case OP_BITWISE_AND:
			return (leftVal & rightVal);
			break;
		case OP_BITWISE_XOR:
			return (leftVal ^ rightVal);
			break;
		case OP_LOGICAL_NOT:
			return (!leftVal);
			break;
		
    }
	return 0;
}